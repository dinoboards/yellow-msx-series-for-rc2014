DIAGENABLE	EQU	0
CPUMHZ:		EQU	3686400	/ 1000 / 1000
CPUSCL:		EQU	CPUMHZ - 2		; OTHERWISE 2 LESS THAN PHI MHZ
; CB_CPUMHZ	DB	CPUMHZ


	PUBLIC	_fdInit, _fdIdle

;
; FLOPPY DISK MEDIA SELECTIONS (ID'S MUST BE INDEX OF ENTRY IN FCD_TBL)
;

;
; FD MODE SELECTIONS
;
FDMODE_NONE	EQU	0
FDMODE_DIO	EQU	1		; DISKIO V1
FDMODE_ZETA	EQU	2		; ZETA
FDMODE_ZETA2	EQU	3		; ZETA V2
FDMODE_DIDE	EQU	4		; DUAL IDE
FDMODE_N8	EQU	5		; N8
FDMODE_DIO3	EQU	6		; DISKIO V3
FDMODE_RCSMC	EQU	7		; RC2014 SMC 9266 @ $40 (SCOTT BAKER)
FDMODE_RCWDC	EQU	8		; RC2014 WDC 37C65 @ $40 (SCOTT BAKER)
FDMODE_DYNO	EQU	9		; DYNO WDC 37C65 @ $84
FDMODE_EPFDC	EQU	10		; RC2014 ETCHED PIXELS FDC
;
; FLOPPY DISK MEDIA SELECTIONS (ID'S MUST BE INDEX OF ENTRY IN FCD_TBL)
;
FDM720		EQU	0		; 3.5" FLOPPY, 720KB, 2 SIDES, 80 TRKS, 9 SECTORS
FDM144		EQU	1		; 3.5" FLOPPY, 1.44MB, 2 SIDES, 80 TRKS, 18 SECTORS
FDM360		EQU	2		; 5.25" FLOPPY, 360KB, 2 SIDES, 40 TRKS, 9 SECTORS
FDM120		EQU	3		; 5.25" FLOPPY, 1.2MB, 2 SIDES, 80 TRKS, 15 SECTORS
FDM111		EQU	4		; 8" FLOPPY, 1.11MB, 2 SIDES, 74 TRKS, 15 SECTORS
;
; MEDIA ID VALUES
;
MID_NONE	EQU	0
MID_MDROM	EQU	1
MID_MDRAM	EQU	2
MID_RF		EQU	3
MID_HD		EQU	4
MID_FD720	EQU	5
MID_FD144	EQU	6
MID_FD360	EQU	7
MID_FD120	EQU	8
MID_FD111	EQU	9
MID_HDNEW	EQU	10


FALSE		EQU	0
TRUE		EQU	~FALSE

;
; HBIOS GLOBAL ERROR RETURN VALUES
;
ERR_NONE		EQU	0	; SUCCESS
;
ERR_UNDEF		EQU	-1	; UNDEFINED ERROR
ERR_NOTIMPL		EQU	-2	; FUNCTION NOT IMPLEMENTED
ERR_NOFUNC		EQU	-3	; INVALID FUNCTION
ERR_NOUNIT		EQU	-4	; INVALID UNIT NUMBER
ERR_NOMEM		EQU	-5	; OUT OF MEMORY
ERR_RANGE		EQU	-6	; PARAMETER OUT OF RANGE
ERR_NOMEDIA		EQU	-7	; MEDIA NOT PRESENT
ERR_NOHW		EQU	-8	; HARDWARE NOT PRESENT
ERR_IO			EQU	-9	; I/O ERROR
ERR_READONLY		EQU	-10	; WRITE REQUEST TO READ-ONLY MEDIA
ERR_TIMEOUT		EQU	-11	; DEVICE TIMEOUT
ERR_BADCFG		EQU	-12	; INVALID CONFIGURATION
ERR_INTERNAL		EQU	-13	; INTERNAL ERROR

; SUB TYPES OF CHAR DEVICES
;
;00 RS-232
;01 TERMINAL
;02 PARALLEL PORT
;03 UNUSED
;
; DISK DEVICE IDS
;
DIODEV_MD	EQU	$00
DIODEV_FD	EQU	$10
DIODEV_RF	EQU	$20
DIODEV_IDE	EQU	$30
DIODEV_ATAPI	EQU	$40
DIODEV_PPIDE	EQU	$50
DIODEV_SD	EQU	$60
DIODEV_PRPSD	EQU	$70
DIODEV_PPPSD	EQU	$80
DIODEV_HDSK	EQU	$90


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FDMAUTO:	EQU	TRUE		; FD: AUTO SELECT DEFAULT/ALTERNATE MEDIA FORMATS
FDCNT		EQU	2		; FD: NUMBER OF FLOPPY DRIVES ON THE INTERFACE (1-2)
FDMODE		EQU	FDMODE_RCWDC	; FD: DRIVER MODE: FDMODE_[DIO|ZETA|DIDE|N8|DIO3]
FDMEDIA		EQU	FDM120		; FD: DEFAULT MEDIA FORMAT FDM[720|144|360|120|111]
FDMEDIAALT	EQU	FDM720		; FD: ALTERNATE MEDIA FORMAT FDM[720|144|360|120|111]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
;==================================================================================================
;   FLOPPY DISK DRIVER
;==================================================================================================
;

	SECTION	CODE
;
FDC_MSR:		EQU	$50		; 8272 MAIN STATUS REGISTER
FDC_DATA:	EQU	$51		; 8272 DATA PORT
FDC_DOR:		EQU	$58		; DIGITAL OUTPUT REGISTER
FDC_DCR:		EQU	$48		; CONFIGURATION CONTROL REGISTER
FDC_TC:		EQU	$58		; TERMINAL COUNT (W/ DACK)
;
; DISK OPERATIONS
;
DOP_READ:	EQU	0		; READ OPERATION
DOP_WRITE:	EQU	1		; WRITE OPERATION
DOP_FORMAT:	EQU	2		; FORMAT OPERATION
DOP_READID:	EQU	3		; READ ID OPERATION
;
; FDC RESULT CODES
;
FRC_OK:		EQU	0		; 00
FRC_NOTIMPL:	EQU	-01H		; FF
FRC_CMDERR:	EQU	-02H		; FE
FRC_ERROR:	EQU	-03H		; FD
FRC_ABORT:	EQU	-04H		; FC
FRC_BUFMAX:	EQU	-05H		; FB
FRC_ABTERM:	EQU	-08H		; F8
FRC_INVCMD:	EQU	-09H		; F7
FRC_DSKCHG:	EQU	-0AH		; F6
FRC_ENDCYL:	EQU	-0BH		; F5
FRC_DATAERR:	EQU	-0CH		; F4
FRC_OVERRUN:	EQU	-0DH		; F3
FRC_NODATA:	EQU	-0EH		; F2
FRC_NOTWRIT:	EQU	-0FH		; F1
FRC_MISADR:	EQU	-10H		; F0
FRC_TOFDCRDY:	EQU	-11H		; EF
FRC_TOSNDCMD:	EQU	-12H		; EE
FRC_TOGETRES:	EQU	-13H		; ED
FRC_TOEXEC:	EQU	-14H		; EC
FRC_TOSEEKWT:	EQU	-15H		; EB
;
; FD DEVICE CONFIGURATION
;
FD_DEVCNT:	EQU	FDCNT		; 2 DEVICES SUPPORTED
FD_CFGSIZ:	EQU	8		; SIZE OF CFG TBL ENTRIES
;
; PER DEVICE DATA OFFSETS
;					; OFFSET OF...
FD_DEV:		EQU	0		; DEVICE NUMBER (BYTE)
FD_STAT:		EQU	1		; LAST STATUS (BYTE)
FD_MEDTYP:	EQU	2		; MEDIA TYPE FDM... (BYTE)
FD_CURTRK:	EQU	3		; CURRENT TRACK (BYTE)
FD_HST:		EQU	4		; HOSTS SEEK POSITION
FD_HSTTRK:	EQU	FD_HST + 0	; HOST TRACK (WORD)
FD_HSTSEC:	EQU	FD_HST + 2	; HOST SECTOR (BYTE)
FD_HSTHD:	EQU	FD_HST + 3	; HOST HEAD (BYTE)
;
	SECTION	DATA
FD_CFGTBL:
	; DEVICE 0, PRIMARY MASTER:
	DB	0			; DEVICE NUMBER:
	DB	0			; DEVICE STATUS:
	DB	FDMEDIA			; MEDIA TYPE:
	DB	$FF			; CURRENT TRACK
	DW	0			; HOST TRACK:
	DB	0			; HOST SECTOR:
	DB	0			; HOST HEAD
IF 0
	; DEVICE 1, PRIMARY SLAVE:
	DB	1			; DRIVER DEVICE NUMBER:
	DB	0			; DEVICE STATUS:
	DB	FDMEDIA			; MEDIA TYPE:
	DB	$FF			; CURRENT TRACK
	DW	0			; HOST TRACK:
	DB	0			; HOST SECTOR:
	DB	0			; HOST HEAD
ENDIF
;
IF ($ - FD_CFGTBL) != (FD_DEVCNT * FD_CFGSIZ)
	;fail	"*** INVALID FD CONFIG TABLE ***\n"
ENDIF
;
	DB	$FF			; END MARKER

;
; FDC COMMANDS
;
CFD_READ:	EQU	00000110B	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
CFD_READDEL:	EQU	00001100B	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
CFD_WRITE:	EQU	00000101B	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
CFD_WRITEDEL:	EQU	00001001B	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
CFD_READTRK:	EQU	00000010B	; CMD,HDS/DS,C,H,R,N,EOT,GPL,DTL --> ST0,ST1,ST2,C,H,R,N
CFD_READID:	EQU	00001010B	; CMD,HDS/DS --> ST0,ST1,ST2,C,H,R,N
CFD_FMTTRK:	EQU	00001101B	; CMD,HDS/DS,N,SC,GPL,D --> ST0,ST1,ST2,C,H,R,N
CFD_SCANEQ:	EQU	00010001B	; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
CFD_SCANLOEQ:	EQU	00011001B	; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
CFD_SCANHIEQ:	EQU	00011101B	; CMD,HDS/DS,C,H,R,N,EOT,GPL,STP --> ST0,ST1,ST2,C,H,R,N
CFD_RECAL:	EQU	00000111B	; CMD,DS --> <EMPTY>
CFD_SENSEINT:	EQU	00001000B	; CMD --> ST0,PCN
CFD_SPECIFY:	EQU	00000011B	; CMD,SRT/HUT,HLT/ND --> <EMPTY>
CFD_DRVSTAT:	EQU	00000100B	; CMD,HDS/DS --> ST3
CFD_SEEK:	EQU	00001111B	; CMD,HDS/DS --> <EMPTY>
CFD_VERSION:	EQU	00010000B	; CMD --> ST0
;
;
; Specify Command:
; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
; |Byte |  7  |	 6  |  5  |  4	|  3  |	 2  |  1  |  0	|
; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
; |  0	|  0  |	 0  |  0  |  0	|  0  |	 0  |  1  |  1	|
; |  1	| ----- STEP RATE ----- | -- HEAD UNLOAD TIME - |
; |  2	| ------------ HEAD LOAD TIME ----------- | NDM |
; +-----+-----+-----+-----+-----+-----+-----+-----+-----+
;
;
; Step Rate (milliseconds):		 Head Unload Time (milliseconds):	Head Load Time (milliseconds):
; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
; |	 |	   BITRATE	     |	 |	|	  BITRATE	    |	|      |	 BITRATE	   |
; |  VAL | 1.0M | 500K | 300K | 250K |	 |  VAL | 1.0M | 500K | 300K | 250K |	|  VAL | 1.0M | 500K | 300K | 250K |
; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
; |    0 |  8.0 | 16.0 | 26.7 | 32.0 |	 |    0 |  128 |  256 |	 426 |	512 |	|    0 |  128 |	 256 |	426 |  512 |
; |    1 |  7.5 | 15.0 | 25.0 | 30.0 |	 |    1 |    8 |   16 | 26.7 |	 32 |	|    1 |    1 |	   2 |	3.3 |	 4 |
; |    2 |  7.0 | 14.0 | 23.3 | 28.0 |	 |    2 |   16 |   32 | 53.3 |	 64 |	|    2 |    2 |	   4 |	6.7 |	 8 |
; |  ... |  ... |  ... |  ... |	 ... |	 |  ... |  ... |  ... |	 ... |	... |	|  ... |  ... |	 ... |	... |  ... |
; |   14 |  1.0 |  2.0 |  3.3 |	 4.0 |	 |   14 |  112 |  224 |	 373 |	448 |	|  126 |  126 |	 252 |	420 |  504 |
; |   15 |  0.5 |  1.0 |  1.7 |	 2.0 |	 |   15 |  120 |  240 |	 400 |	480 |	|  127 |  127 |	 254 |	423 |  508 |
; +------+------+------+------+------+	 +------+------+------+------+------+	+------+------+------+------+------+
;
; IBM PS/2 CALLS FOR:
;   STEP RATE: 3ms (6ms FOR ALL 41mm OR 720K DRIVES)
;   HEAD LOAD TIME: 15ms
;
; STATIC CONFIGURATION, NEVER CHANGES (PRIVATE)
;
FCD_MT:		EQU	000H		; MULTI-TRACK, WE DON'T USE, SET TO 0
FCD_MFM:	EQU	001H		; MFM, 0=FM, 1=MFM, WE USE MFM ALWAYS
FCD_SK:		EQU	000H		; SKIP MODE, WE DON'T USE, SET TO 0
FCD_N:		EQU	002H		; SECTOR SIZE, N=2 FOR 512 BYTES
FCD_DTL:	EQU	0FFH		; DATA LENGTH (WHEN N=0, SET TO FF OTHERWISE)
FCD_STP:	EQU	001H		; SECTOR SCAN TYPE, 1=CONTIG, 2=ALTERNATING
;
FCD_PC720:	DB	050H		; NUMBER OF CYLINDERS:
		DB	002H		; NUMBER OF HEADS:
		DB	009H		; NUMBER OF SECTORS:
		DB	001H		; START OF TRACK (ID OF FIRST SECTOR, USUALLY 1)
		DB	009H		; SECTOR COUNT
		DW	200H		; SECTOR SIZE IN BYTES:
		DB	02AH		; GAP LENGTH (R/W)
		DB	050H		; GAP LENGTH (FORMAT)
		DB	(13 << 4) | 0	; SRT = 6ms, HUT = 512ms:
		DB	(4 << 1) | 1	; HLT = 16ms, ND = YES:
		DB	DOR_BR250	; DOR:
		DB	DCR_BR250	; DCR
IF	(($ - FCD_PC720) != FCD_LEN)
;ECHO	"*** FCD_PC720 SIZE ERROR!!! ***\n"
ENDIF
;
FCD_PC144:	DB	050H		; NUMBER OF CYLINDERS:
		DB	002H		; NUMBER OF HEADS:
		DB	012H		; NUMBER OF SECTORS:
		DB	001H		; START OF TRACK (ID OF FIRST SECTOR, USUALLY 1)
		DB	012H		; SECTOR COUNT
		DW	200H		; SECTOR SIZE IN BYTES:
		DB	01BH		; GAP LENGTH (R/W)
		DB	06CH		; GAP LENGTH (FORMAT)
		DB	(13 << 4) | 0	; SRT = 3ms, HUT = 256ms:
		DB	(8 << 1) | 1	; HLT = 16ms, ND = YES:
		DB	DOR_BR500	; DOR:
		DB	DCR_BR500	; DCR
IF	(($ - FCD_PC144) != FCD_LEN)
;.ECHO	"*** FCD_PC144 SIZE ERROR!!! ***\n"
ENDIF
;
FCD_PC360:	DB	028H		; NUMBER OF CYLINDERS:
		DB	002H		; NUMBER OF HEADS:
		DB	009H		; NUMBER OF SECTORS:
		DB	001H		; START OF TRACK (ID OF FIRST SECTOR, USUALLY 1)
		DB	009H		; SECTOR COUNT
		DW	200H		; SECTOR SIZE IN BYTES:
		DB	02AH		; GAP LENGTH (R/W)
		DB	050H		; GAP LENGTH (FORMAT)
		DB	(13 << 4) | 0	; SRT = 6ms, HUT = 512ms:
		DB	(4 << 1) | 1	; HLT = 16ms, ND = YES:
		DB	DOR_BR250	; DOR:
		DB	DCR_BR250	; DCR
IF	(($ - FCD_PC360) != FCD_LEN)
;.ECHO	"*** FCD_PC360 SIZE ERROR!!! ***\n"
ENDIF
;
FCD_PC120:	DB	050H		; NUMBER OF CYLINDERS:
		DB	002H		; NUMBER OF HEADS:
		DB	00FH		; NUMBER OF SECTORS:
		DB	001H		; START OF TRACK (ID OF FIRST SECTOR, USUALLY 1)
		DB	00FH		; SECTOR COUNT
		DW	200H		; SECTOR SIZE IN BYTES:
		DB	01BH		; GAP LENGTH (R/W)
		DB	054H		; GAP LENGTH (FORMAT)
		DB	(10 << 4) | 0	; SRT = 6ms, HUT = 256ms:
		DB	(8 << 1) | 1	; HLT = 16ms, ND = YES:
		DB	DOR_BR500	; DOR:
		DB	DCR_BR500	; DCR
IF	(($ - FCD_PC120) != FCD_LEN)
;ECHO	"*** FCD_PC120 SIZE ERROR!!! ***\n"
ENDIF
;
FCD_PC111:	DB	04DH		; NUMBER OF CYLINDERS:
		DB	002H		; NUMBER OF HEADS:
		DB	00FH		; NUMBER OF SECTORS:
		DB	001H		; START OF TRACK (ID OF FIRST SECTOR, USUALLY 1)
		DB	00FH		; SECTOR COUNT
		DW	200H		; SECTOR SIZE IN BYTES:
		DB	01BH		; GAP LENGTH (R/W)
		DB	054H		; GAP LENGTH (FORMAT)
		DB	(13 << 4) | 0	; SRT = 3ms, HUT = 256ms:
		DB	(25 << 1) | 1	; HLT = 50ms, ND = YES:
		DB	DOR_BR500	; DOR:
		DB	DCR_BR500	; DCR
IF	(($ - FCD_PC111) != FCD_LEN)
;.ECHO	"*** FCD_PC111 SIZE ERROR!!! ***\n"
ENDIF

	SECTION	CODE
;
; FCD LOOKUP TABLE (CALLED TO SET HL TO ADDRESS OF MEDIA DATA ABOVE)
; ENTRIES BELOW MUST MATCH COUNT AND VALUES OF FDMXXX IN STD.ASM
;
FCD_TBL:
		LD	HL,FCD_PC720
		RET	; FDM720 = 0

		LD	HL,FCD_PC144
		RET	; FDM144 = 1

		LD	HL,FCD_PC360
		RET	; FDM360 = 2

		LD	HL,FCD_PC120
		RET	; FDM120 = 3

		LD	HL,FCD_PC111
		RET	; FDM111 = 4

;
; *** DIDE/N8/ZETA V2 ***
;
DOR_INIT:	EQU	00001100B	; SOFT RESET INACTIVE, DMA ENABLED
DOR_BR250:	EQU	DOR_INIT
DOR_BR500:	EQU	DOR_INIT
;
; DCR (ONLY APPLIES TO DIDE, N8, AND ZETA V2)
;
DCR_BR250:	EQU	01H		; 250KBPS
DCR_BR500:	EQU	00H		; 500KBPS
;
;
;
FD_DEVICE:
	LD	D,DIODEV_FD		; D := DEVICE TYPE
	LD	E,(IY+FD_DEV)		; E := PHYSICAL DEVICE NUMBER
IF (FDMEDIA == FDM720)
	LD	C,%11010100		; 3.5" DS/DD
ENDIF
IF (FDMEDIA == FDM144)
	LD	C,%11011000		; 3.5" DS/HD
ENDIF
IF (FDMEDIA == FDM360)
	LD	C,%10110100		; 5.25" DS/DD
ENDIF
IF (FDMEDIA == FDM120)
	LD	C,%10111000		; 5.25" DS/HD
ENDIF
IF (FDMEDIA == FDM111)
	LD	C,%10010100		; 8" DS/DD
ENDIF
	LD	H,FDMODE		; H := MODE
	LD	L,FDC_MSR		; L := BASE I/O ADDRESS
	XOR	A			; SIGNAL SUCCESS
	RET
;
; FD_MEDIA
;
FD_MEDIA:
	LD	A,E			; GET FLAGS
	OR	A			; SET FLAGS
	JR	Z,FD_MEDIA4		; JUST REPORT CURRENT STATUS AND MEDIA

IF (FDMAUTO)
	; SETUP TO READ TRK 0, HD 0, SEC 0
	;LD	A,C			; C STILL HAS REQUESTED DRIVE
	LD	A,(IY+FD_DEV)		; GET DRIVE UNIT
	;AND	0FH
	LD	(FCD_DS),A
	LD	A,0
	LD	(FCD_C),A
	LD	(FCD_H),A
	INC	A
	LD	(FCD_R),A
	LD	A,DOP_READID
	LD	(FCD_DOP),A

	LD	B,5

FD_MEDIARETRY:
	; TRY PRIMARY MEDIA CHOICE FIRST
	LD	A,FDMEDIA
	CALL	FD_TESTMEDIA
	JR	Z,FD_MEDIA3		; IF SUCCESS, WE ARE DONE

	; TRY ALTERNATE MEDIA CHOICE
	LD	A,FDMEDIAALT
	CALL	FD_TESTMEDIA
	JR	Z,FD_MEDIA3		; IF SUCCESS, WE ARE DONE

	DJNZ	FD_MEDIARETRY

	; NO JOY, RETURN WITH E=0 (NO MEDIA)
	;LD	HL,(FDDS_MEDIAADR)
	;LD	(HL),0			; SET TO NO MEDIA
	LD	(IY+FD_MEDTYP),0	; SET DRIVE = NO MEDIA
	LD	E,0
	LD	A,ERR_NOMEDIA		; SIGNAL ERROR
	OR	A			; SET FLAGS
	RET

FD_TESTMEDIA:
	;LD	HL,(FDDS_MEDIAADR)
	;LD	(HL),A
	LD	(IY+FD_MEDTYP),A
	PUSH	BC
	CALL	FD_START
	POP	BC
	RET

FD_MEDIA3:

ENDIF

FD_MEDIA4:

	LD	A,(IY+FD_MEDTYP)	; GET CURRENT MEDIA TYPE
	ADD	A,MID_FD720		; ASSUMES MID_ VALUES ARE IN SAME ORDER AS FDM VALUES

	LD	E,A			; MOVE MEDIA VALUE TO E
	XOR	A			; SIGNAL SUCCESS
	RET
;
;
;
FD_CAP:
	CALL	FD_GEOM		; GET GEOMETRY
	; HL=TRACKS, D=HEADS, E=SECTORS
	PUSH	HL			; SAVE TRACK COUNT
	LD	H,D			; HEADS COUNT TO H
	RES	7,H			; MAKE SURE LBA CAPABILITY BIT IS CLEARED
	CALL	MULT8			; HL := H * E FOR SECTORS / CYL
	POP	DE			; RECOVER TRACKS, E == TRACK COUNT
	LD	H,L			; MOVE WORKING COUNT L --> H
	CALL	MULT8			; HL := H * E FOR TOTAL SECTORS
	LD	DE,0			; HI WORD ALWAYS ZERO
	XOR	A			; SIGNAL SUCCESS
	RET				; DONE
;
;
;
FD_GEOM:
	LD	A,(IY+FD_MEDTYP)	; GET CURRENT MEDIA TYPE
	RLCA				; TABLE IS 4 BYTE ENTRIES
	RLCA				; A = A * 4
	LD	HL,FCD_TBL		; HL = START OF TABLE
	LD	D,0			; SET DE TO TABLE OFFSET
	LD	E,A
	ADD	HL,DE			; OFFSET BASED ON DESIRED MEDIA
	CALL	JPHL			; CALL THE TABLE ENTRY (SEE FCD_TBL)
	; HL NOW POINTS TO START OF DESIRED MEDIA INFO
	LD	A,(HL)			; GET TRACKS
	INC	HL			; POINT TO HEADS
	LD	D,(HL)			; GET HEADS
	SET	7,D			; SET LBA CAPABILITY BIT
	INC	HL			; POINT TO SECTORS
	LD	E,(HL)			; GET SECTORS
	LD	L,A			; L := TRACKS
	LD	H,0			; HI WORD OF TRACKS IS ALWAYS ZERO
	XOR	A			; SIGNAL SUCCESS
	RET				; DONE
;
; FD_INIT
;
_fdInit:
FD_INIT:
;
; SETUP THE DISPATCH TABLE ENTRIES
;
	LD	B,FD_DEVCNT		; LOOP CONTROL
	LD	IY,FD_CFGTBL		; START OF CFG TABLE
FD_INIT0:
	PUSH	BC			; SAVE LOOP CONTROL
	CALL	FD_INITUNIT		; DO UNIT INITIALIZATION
	LD	BC,FD_CFGSIZ		; SIZE OF CFG ENTRY
	ADD	IY,BC			; BUMP IY TO NEXT ENTRY
	POP	BC			; RESTORE BC
	DJNZ	FD_INIT0		; LOOP AS NEEDED
;
	LD	BC,0
	LD	(FCD_IDLECNT),BC
;
	LD	A,DOR_INIT
	LD	(FST_DOR),A
;
	CALL	FC_RESETFDC
	CALL	FD_CLRDSKCHG
;
	LD	A,TRUE
	LD	(FCD_FDCRDY),A
;
	RET
;
; UNIT INITIALIZATION
;
FD_INITUNIT:
	LD	(IY+FD_STAT),0		; CLEAR STATUS
	LD	(IY+FD_MEDTYP),FDMEDIA	; SET DEFAULT MEDIA TYPE
	LD	(IY+FD_CURTRK),$FE	; SPECIAL VALUE FOR CURTRK
	RET
;
; FD_IDLE QUIESCES THE FLOPPY SUBSYSTEM (MOTOR OFF)
; AFTER BEING CALLED ENOUGH TIMES...
; SHOULD IT INVALIDATE THE BUFFER???
;
_fdIdle:
FD_IDLE:
	LD	BC,(FCD_IDLECNT)
	LD	A,B
	OR	C
	RET	Z			; COUNTER ALREADY FIRED

	DEC	BC			; DECREMENT COUNTER
	LD	(FCD_IDLECNT),BC	; SAVE IT
	LD	A,B
	OR	C
	RET	NZ			; STILL COUNTING DOWN, RETURN

	CALL	FC_MOTOROFF		; COUNTER JUST EXPIRED, SHUTDOWN MOTOR!
	RET
;
; FD_STATUS
;
FD_STATUS:
	LD	A,(IY+FD_CURTRK)	; A = CURRENT TRACK

	CP	0FFH			; IS CURRENT TRACK = $FF?
	JR	Z,FD_STATUS1		; IF SO, NOT READY

	XOR	A			; A = 0 = OK
	RET				; RETURN

FD_STATUS1:
	OR	A			; A ALREADY = $FF, JUST SET FLAGS
	RET
;
;
;
FD_RESET:
	XOR	A			; ALWAYS OK
	RET
;
; FD_CLRDSKCHG
;
FD_CLRDSKCHG:
	; PROCESS ANY PENDING DISK CHANGE NOTIFICATIONS
	LD	B,5
FD_CLRDSKCHG1:
	PUSH	BC
	CALL	FC_SENSEINT
	POP	BC
	LD	A,(FST_RC)
	CP	FRC_DSKCHG
	RET	NZ			; NO MORE DISK CHANGE NOTIFICATIONS
	DJNZ	FD_CLRDSKCHG1
;
; FD_WTSEEK
;
; WAIT FOR PENDING SEEK OPERATION TO COMPLETE BY POLLING SENSEINT
; AND WAITING FOR ABTERM OR OK.
;
FD_WTSEEK:
	LD	BC,1000H

FD_WTSEEKLOOP:
	PUSH	BC
	CALL	FC_SENSEINT
	POP	BC

	LD	A,(FST_RC)		; CHECK RC
	CP	FRC_ABTERM		; ABTERM = DONE/FAILED
	JR	Z,FD_RETRC
	CP	FRC_OK			; OK = DONE/SUCCESS
	JR	Z,FD_RETRC

	DEC	BC			; CHECK LOOP COUNTER IN BC
	LD	A,B			; "
	OR	C			; "
	JR	NZ,FD_WTSEEKLOOP	; LOOP UNTIL COUNTER EXHAUSTED

FD_RETRC:
	LD	A,(FST_RC)
	OR	A
	RET				; TIMEOUT/FAILED
;
; FD_FDCRESET
;
FD_FDCRESET:
	CALL	FC_RESETFDC

	CALL	FD_CLRDSKCHG

	LD	A,TRUE
	LD	(FCD_FDCRDY),A

	; MARK ALL DRIVES AS NEEDING RECALIBRATION
	; NOTE THAT IF THE VALUE IS CURRENTLY $FF,
	; WE NEED TO LEAVE IT ALONE, SO WE 'OR' IN THE
	; $FE TO AVOID THIS SCENARIO.

	PUSH	IY			; SAVE CURRENT IY
	LD	B,FD_DEVCNT		; LOOP CONTROL
	LD	DE,FD_CFGSIZ		; SIZE OF CFG ENTRY
	LD	IY,FD_CFGTBL		; START OF CFG TABLE
FD_FDCRESET1:
	LD	A,(IY+FD_CURTRK)	; GET CURRENT TRACK
	OR	$FE			; APPLY NEW VALUE
	LD	(IY+FD_CURTRK),A	; UPDATE TRACK
	ADD	IY,DE			; BUMP IY TO NEXT ENTRY
	DJNZ	FD_FDCRESET1		; LOOP AS NEEDED
	POP	IY			; RESTORE IY

	RET
;
; FD_DRIVERESET
;
; ATTEMPT TO FULLY RESET FLOPPY DRIVE, PRIMARILY RECALIBRATE
;
FD_DRIVERESET:
	CALL	FC_SPECIFY
	RET	NZ			; ERROR, BAIL OUT

	CALL	FC_RECAL
	RET	NZ			; ERROR, BAIL OUT

	; FIRST RECAL MAY FAIL TO REACH TRACK 0
	; SO WE TRY ONCE MORE IN CASE OF A FAILURE
	CALL	FD_WTSEEK
	RET	Z

	; SECOND TRY, ONLY IF NEEDED
	CALL	FC_RECAL
	RET	NZ			; ERROR, BAIL OUT

	CALL	FD_WTSEEK
	RET
;
;
;
FD_SEEK:
	; DE:HL CONTAINS EITHER LBA OR CHS
	BIT	7,D			; TEST LBA BIT
	JR	Z,FD_SEEK9		; IF NOT LBA, JUST SAVE INCOMING VALUE
	; NEED TO CONVERT LBA IN DE:HL TO CHS
	; NOTE: FLOPPY LBA WILL NEVER EXCEED 16 BITS, SO WE IGNORE DE ENTIRELY
	PUSH	HL			; SAVE HL
	CALL	FD_GEOM			; E := SPT, D := HDS
	POP	HL			; RESTORE HL
	RET	NZ			; BAIL OUT ON ERROR
	RES	7,D			; MAKE SURE LBA BIT IS CLEARED
	LD	(FD_CURGEOM),DE		; SAVE AS FD_CURSPT & FD_CURHDS
	LD	A,(FD_CURSPT)		; A := SECTORS PER TRACK
	LD	D,0			; DE := SPT
	LD	E,A
	CALL	DIV16			; DIVIDE, REMAINDER (SECTOR #) IN HL
	PUSH	HL			; SAVE SECTOR #
	PUSH	BC			; CYLINDERS AND HEADS BACK TO HL
	POP	HL
	LD	A,(FD_CURHDS)		; A := HEADS PER CYLINDER
	LD	D,0			; DE : = HEADS PER CYLINDER
	LD	E,A
	CALL	DIV16			; DIVIDE, BC := TRACK, REMAINDER (HEAD #) IN HL
	PUSH	HL			; SAVE HEAD #
	PUSH	BC			; COPY TRACK # TO HL
	POP	HL
	POP	BC			; RECOVER HEAD #
	LD	D,C			; HEAD # TO D
	POP	BC			; RECOVER SECTOR #
	LD	E,C			; SECTOR # TO E
FD_SEEK9:	; NOT LBA, JUST SAVE THE CHS VALUE IN CFG ENTRY
	PUSH	HL			; SAVE INCOMING HL TO (SP)
	LD	A,FD_HST		; A := HST OFFSET IN CFG ENTRY
	CALL	LDHLIYA			; HL := HST VALUE ADR
	EX	(SP),HL			; RESTORE INCOMING HL, HST ADR TO (SP)
	POP	BC			; HST ADR TO BC
	CALL	ST32			; SAVE HST IN CFG ENTRY
	XOR	A			; SIGNAL SUCCESS
	RET
;
FD_READ:
	CALL	HB_DSKREAD		; HOOK HBIOS DISK READ SUPERVISOR
	LD	(FD_DSKBUF),HL		; SAVE DISK BUFFER ADDRESS
	LD	A,DOP_READ
	JR	FD_RW
;
FD_WRITE:
	CALL	HB_DSKWRITE		; HOOK HBIOS DISK WRITE SUPERVISOR
	LD	(FD_DSKBUF),HL		; SAVE DISK BUFFER ADDRESS
	LD	A,DOP_WRITE
	JR	FD_RW
;
FD_RW:
	LD	(FCD_DOP),A		; SAVE REQUESTED DISK OPERATION
	LD	A,E			; BLOCK COUNT TO A
	OR	A			; SET FLAGS
	RET	Z			; ZERO SECTOR I/O, RETURN W/ E=0 & A=0
	LD	B,A			; INIT SECTOR DOWNCOUNTER
	LD	C,0			; INIT SECTOR READ/WRITE COUNT

	PUSH	BC			; SAVE COUNTERS
	CALL	FD_GEOM			; E := SPT, D := HDS
	POP	BC			; RESTORE COUNTERS
	JR	NZ,FD_RW4		; BAIL OUT ON ERROR
	RES	7,D			; MAKE SURE LBA BIT IS CLEARED
	LD	(FD_CURGEOM),DE		; SAVE AS FD_CURSPT & FD_CURHDS

FD_RW1:
	PUSH	BC			; SAVE COUNTERS
	CALL	FD_RUN			; PERFORM SECTOR READ/WRITE
	JR	NZ,FD_RW3		; IF ERROR, SKIP INCREMENT

	; INCREMENT SECTOR AND CHECK FOR TRACK OVERFLOW
	LD	A,FD_HSTSEC		; HST SECTOR OFFSET IN CFG
	CALL	LDHLIYA			; HL := ADR OF HST SECTOR
	INC	(HL)			; INCREMENT SECTOR
	LD	A,(FD_CURSPT)		; A := SECTORS PER TRACK
	CP	(HL)			; COMPARE SPT TO CURRENT SECTOR
	JR	NZ,FD_RW2		; IF NO OVERFLOW, DONE

	; RESET SECTOR, INCREMENT HEAD, AND CHECK FOR CYLINDER OVERFLOW
	LD	(HL),0			; RESET SECTOR TO ZERO
	INC	HL			; POINT TO HST HEAD
	INC	(HL)			; INCREMENT HEAD
	LD	A,(FD_CURHDS)		; A : = HEADS
	CP	(HL)			; COMPARE HEADS TO HST HEAD
	JR	NZ,FD_RW2		; IF NO OVERFLOW, DONE

	; RESET HEAD AND INCREMENT TRACK
	LD	(HL),0			; RESET HEAD TO ZERO
	DEC	HL			; POINT TO HST TRACK
	DEC	HL			; ...
	DEC	HL			; ...
	INC	(HL)			; INCREMENT HST TRACK LSB

FD_RW2:
	LD	HL,FD_DSKBUF+1		; POINT TO MSB OF BUFFER ADR
	INC	(HL)			; BUMP DMA BY
	INC	(HL)			; ... 512 BYTES
	XOR	A			; SIGNAL SUCCESS
FD_RW3:
	POP	BC			; RECOVER COUNTERS
	JR	NZ,FD_RW4		; IF ERROR, BAIL OUT
	INC	C			; BUMP COUNT OF SECTORS READ
	DJNZ	FD_RW1			; LOOP AS NEEDED
FD_RW4:
	LD	E,C			; SECTOR READ COUNT TO E
	LD	HL,(FD_DSKBUF)		; CURRENT DMA TO HL
	OR	A			; SET FLAGS BASED ON RETURN CODE
	RET				; AND RETURN, A HAS RETURN CODE

;
FD_RUN:
	; UPDATE DRIVE SELECTION
	LD	A,(IY+FD_DEV)		; GET UNIT
	LD	(FCD_DS),A		; UPDATE FCD_DS TO NEW VALUE

	; MAP HSTTRK TO FCD_H, FCD_C
	LD	A,(IY+FD_HSTTRK)	; GET TRACK VALUE (CYLINDER IS MORE ACCURATE)
	LD	(FCD_C),A		; ... AND MOVE IT TO CYL PARM
	LD	A,(IY+FD_HSTHD)		; GET HEAD VALUE
	LD	(FCD_H),A		; ... AND MOVE IT TO HEAD PARM

	; MAP HSTSEC TO FCD_R
	LD	A,(IY+FD_HSTSEC)
	INC	A			; SWITCH FROM ZERO BASED TO ONE BASED
	LD	(FCD_R),A

	; SET RETRY COUNTER
	LD	B,5
FD_RETRY:
	PUSH	BC
	CALL	FD_START
	POP	BC

	LD	A,(FST_RC)		; CHECK RESULT
	OR	A
	RET	Z			; SUCCESS

	DJNZ	FD_RETRY		; RETRY TILL COUNTER EXHAUSTED


	; RETURN APPROPRIATE HBIOS ERROR
	LD	A,(FST_RC)
	CP	FRC_NOTWRIT
	LD	A,ERR_READONLY		; ASSUME WRITE PROTECTED ERROR
	JR	Z,FD_RETRY1
	LD	A,ERR_IO		; OTHERWISE I/O ERROR
FD_RETRY1:
	OR	A			; SET FLAGS
	RET				; AND GIVE UP
;
;
;
FD_START:
	LD	A,(FCD_FDCRDY)
	CP	TRUE
	CALL	NZ,FD_FDCRESET

	; COPY MEDIA CONFIG INTO FCD
	; THIS IS HERE TO ACCOMMODATE DIFFERENT MEDIA
	; IN DIFFERENT FLOPPY UNITS.
	LD	A,(IY+FD_MEDTYP)	; A = MEDIA BYTE
	RLCA				; TABLE IS 4 BYTE ENTRIES
	RLCA				; A = A * 4
	LD	HL,FCD_TBL		; HL = START OF TABLE
	LD	D,0			; SET DE TO TABLE OFFSET
	LD	E,A
	ADD	HL,DE			; OFFSET BASED ON DESIRED MEDIA
	CALL	JPHL			; CALL THE TABLE ENTRY (SEE FCD_TBL)
	LD	DE,FCD			; DE = DESTINATION
	LD	BC,FCD_LEN		; BC = BYTES TO COPY
	LDIR				; BYTES COPY FROM MDB TO FCD

	CALL	FC_MOTORON		; INCLUDES LATCH SETUP

	LD	A,(IY+FD_CURTRK)
	CP	0FEH			; FF = DRIVE NEEDS TO BE RESET
	JR	C,FD_RUN0		; NO RESET NEEDED, BYPASS

	CALL	FD_DRIVERESET
	JR	NZ,FD_RUNERR

	LD	(IY+FD_CURTRK),0	; ZERO CUR TRACK POS

FD_RUN0:
	; COMPARE CURRENT TRACK WITH REQUESTED TRACK TO SEE IF SEEK NEEDED
	LD	A,(FCD_C)
	CP	(IY+FD_CURTRK)
	JR	Z,FD_RUN1		; FDDS_TRKADR == FCD_C, SKIP SEEK

	; INITIATE SEEK TO NEW TRACK
	CALL	FC_SEEK
	JR	NZ,FD_RUNERR

	; WAIT FOR SEEK TO COMPLETE
	CALL	FD_WTSEEK
	JR	NZ,FD_RUNERR

	; RECORD NEW CURRENT TRACK
	LD	A,(FCD_C)
	LD	(IY+FD_CURTRK),A

FD_RUN1:
	; GET THE REQUESTED OPERATION
	LD	A,(FCD_DOP)

	; SETUP RETURN ADDRESS
	LD	HL,FD_RUNCHK
	PUSH	HL

	; DISPATCH TO FUNCTION
	CP	DOP_READ
	JR	Z,FC_READ
	CP	DOP_WRITE
	JR	Z,FC_WRITE
	CP	DOP_READID
	JR	Z,FC_READID
	LD	A,ERR_NOFUNC
	OR	A
	RET

FD_RUNCHK:

FD_RUNEXIT:
	LD	A,(FST_RC)
	OR	A
	RET	Z

FD_RUNERR:
	; INDICATE THAT A CONTROLLER RESET IS DESIRED
	LD	A,FALSE
	LD	(FCD_FDCRDY),A

	; FLAG DRIVE IN ERROR STATUS BY SETTING TRKADR == FF
	LD	(IY+FD_CURTRK),$FF

	JP	FD_RETRC

;
;===============================================================================
; FLOPPY DISK CONTROL SERVICES (PHYSICAL DEVICE CONTROL FOR FDC HARDWARE)
;===============================================================================
;
; ENTRY POINTS FOR FDC COMMANDS
;
FC_READ:
	LD	A,CFD_READ | 11100000B
	CALL	FC_SETUPIO
	JP	FOP

FC_WRITE:
	LD	A,CFD_WRITE | 11000000B
	CALL	FC_SETUPIO
	JP	FOP

FC_READID:
	LD	A,CFD_READID | 01000000B
	CALL	FC_SETUPCMD
	JP	FOP

FC_RECAL:
	LD	A,CFD_RECAL | 00000000B
	CALL	FC_SETUPCMD
	JP	FOP		; FIX: DO WE NEED TO REMOVE HDS BITS FROM SECOND BYTE?

FC_SENSEINT:
	LD	A,CFD_SENSEINT | 00000000B
	CALL	FC_SETUPCMD
	LD	A,1		; GENERIC COMMAND, BUT JUST FIRST COMMAND CODE
	LD	(FCP_LEN),A
	JP	FOP

FC_SPECIFY:
	LD	A,CFD_SPECIFY | 00000000B
	CALL	FC_SETUPSPECIFY
	JP	FOP

FC_DRVSTAT:
	LD	A,CFD_DRVSTAT | 00000000B
	CALL	FC_SETUPCMD
	JP	FOP

FC_SEEK:
	LD	A,CFD_SEEK | 00000000B
	CALL	FC_SETUPSEEK
	JP	FOP
;
; HELPER FUNCTIONS TO SETUP CMDBUF
;
FC_SETUPCMD:
	; TRICKY...  THE INCOMING BYTE IN A MUST CONTAIN THE COMMAND CODE ITSELF
	; IN THE LOW 5 BITS PLUS IT MUST SET WHICH OF THE DESIRED BITS IT WANTS
	; IN THE HIGH 3 BITS.  WE 'AND' THIS WITH THE TEMPATE BITS TO PRODUCE
	; THE CORRECT FINAL COMMAND BYTE
	LD	DE,FCP_BUF
	AND	5FH			; MT=0, MFM=1, SK=0, CMD=11111
	LD	(DE),A			; SAVE THE BYTE
	AND	00011111B		; ISOLATE JUST THE COMMAND BITS
	LD	(FCP_CMD),A		; SAVE IT FOR LATER
	INC	DE

	LD	A,(FCD_H)		; START WITH HDS
	AND	01H			; MASK TO REMOVE IRRELEVANT BITS FOR SAFETY
	RLCA				; MAKE ROOM FOR DS BITS
	RLCA				;
	LD	B,A			; SAVE WHAT WE HAVE SO FAR IN B
	LD	A,(FCD_DS)		; GET DS VALUE
	AND	03H			; MASK TO REMOVE IRRELEVANT BITS FOR SAFETY
	OR	B			; COMBINE WITH SAVED
	LD	(DE),A			; SAVE THE BYTE
	INC	DE

	LD	A,2			; LENGTH IS 2 BYTES AT THIS POINT
	LD	(FCP_LEN),A

	RET

FC_SETUPIO:
	CALL	FC_SETUPCMD

	LD	A,(FCD_C)
	LD	(DE),A
	INC	DE

	LD	A,(FCD_H)
	LD	(DE),A
	INC	DE

	LD	A,(FCD_R)
	LD	(DE),A
	INC	DE

	LD	A,FCD_N
	LD	(DE),A
	INC	DE

	LD	A,(FCD_EOT)
	LD	(DE),A
	INC	DE

	LD	A,(FCD_GPL)
	LD	(DE),A
	INC	DE

	LD	A,FCD_DTL
	LD	(DE),A
	INC	DE

	LD	A,9
	LD	(FCP_LEN),A

	RET

FC_SETUPSEEK:
	CALL	FC_SETUPCMD		; START WITH GENERIC IO CMD

	LD	A,(FCD_C)
	LD	(DE),A
	INC	DE

	LD	A,3
	LD	(FCP_LEN),A

	RET

FC_SETUPSPECIFY:
	CALL	FC_SETUPCMD
	DEC	DE			; BACKUP 1 BYTE, WE ONLY WANT FIRST BYTE

	LD	A,(FCD_SRTHUT)
	LD	(DE),A			; SAVE THE BYTE
	INC	DE

	LD	A,(FCD_HLTND)
	LD	(DE),A			; SAVE THE BYTE
	INC	DE

	LD	A,3
	LD	(FCP_LEN),A

	RET
;
; SET FST_DOR
;
FC_SETDOR:
	LD	(FST_DOR),A
	OUT	(FDC_DOR),A
	RET
;
; SET FST_DCR
;
FC_SETDCR:
	LD	(FST_DCR),A
	OUT	(FDC_DCR),A
	RET
;
;
; RESET FDC BY PULSING BIT 7 OF LATCH LOW
;
FC_RESETFDC:
	LD	A,(FST_DOR)
	PUSH	AF

	LD	A,0
	CALL	FC_SETDOR
	CALL	DELAY
	POP	AF
	CALL	FC_SETDOR

	LD	DE,150			; DELAY: 16us * 150 = 2.4ms
	CALL	VDELAY
	RET
;
; PULSE TERMCT TO TERMINATE ANY ACTIVE EXECUTION PHASE
;
FC_PULSETC:
	IN	A,(FDC_TC)
	RET
;
; SET FST_DOR FOR MOTOR CONTROL ON
;
FC_MOTORON:
;	LD	BC,300H
;	LD	BC,50H
;	LD	(FCD_IDLECNT),BC

	LD	A, CPUMHZ
	RLCA
	LD	(FCD_IDLECNT),A

	; SETUP DCR FOR DIDE HARDWARE
	LD	A,(FCD_DCR)		; GET NEW DCR VALUE
	CALL	FC_SETDCR		; AND IMPLEMENT IT

	LD	HL,FST_DOR		; POINT TO FDC_DOR
	LD	A,(HL)			; START WITH CURRENT DOR
	PUSH	AF
	AND	11111100B		; GET RID OF ANY ACTIVE DS BITS
	LD	C,A			; SAVE IT FOR NOW
	LD	A,(FCD_DS)		; NOW GET CURRENT DS
	LD	B,A			; PUT IN B FOR LATER
	OR	C			; COMBINE WITH SAVED DOR
	LD	C,A			; RE-SAVE IT
	INC	B			; SET UP B AS LOOP COUNTER (DS + 1)
	LD	A,00001000B		; STARTING BIT PATTERN FOR MOTOR
FC_MOTORON1:
	RLA				; SHIFT LEFT
	DJNZ	FC_MOTORON1		; DS TIMES
	OR	C			; COMBINE WITH SAVED
	LD	(HL),A			; COMMIT THE NEW VALUE TO FST_DOR
	CALL	FC_SETDOR		; OUTPUT TO CONTROLLER

	LD	C,A
	POP	AF
	CP	C
	RET	Z			; MOTOR WAS PREVIOUSLY ON

	CALL	LDELAY			; DELAY FOR MOTOR SPINUP IF NOT PREVIOUSLY ON
	RET
;
; SET FST_DOR FOR MOTOR CONTROL OFF
;
FC_MOTOROFF:
	LD	A,(FCD_FDCRDY)
	CP	TRUE
	CALL	NZ,FD_FDCRESET

	LD	A,DOR_INIT
	CALL	FC_SETDOR		; OUTPUT TO CONTROLLER

	RET
;
;===============================================================================
; FDC OPERATIONS
;===============================================================================
;
FOP:
;
; INITIALIZATION
;
	LD	A,0
	LD	(FRB_LEN),A

	LD	A,FRC_OK
	LD	(FST_RC),A
;
; CLEAR FDC, DISCARD ANY PENDING BYTES (GARBAGE?)
;
	LD	B,0			; B IS LOOP COUNTER
FOP_CLR1:
	CALL	DELAY			; FDC MAY TAKE UP TO 12us TO UPDATE MSR
	IN	A,(FDC_MSR)		; GET STATUS
	AND	0C0H			; ISOLATE HIGH NIBBLE, RQM/DIO/NDM/CB
	CP	0C0H			; LOOKING FOR RQM=1, DIO=1, BYTES PENDING
	JR	NZ,FOP_CMD1		; NO BYTES PENDING, GO TO NEXT PHASE
	IN	A,(FDC_DATA)		; GET THE PENDING BYTE AND DISCARD
	DJNZ	FOP_CLR1
	JP	FOP_TOFDCRDY		; OTHERWISE, TIMEOUT
;
; SEND COMMAND
;
FOP_CMD1:
	LD	HL,FCP_BUF
	LD	A,(FCP_LEN)
	LD	D,A			; D = CMD BYTES TO SEND

FOP_CMD2:	; START OF LOOP TO SEND NEXT BYTE
	LD	B,0			; B IS LOOP COUNTER

FOP_CMD4:	; START OF STATUS LOOP, WAIT FOR FDC TO BE READY FOR BYTE
	CALL	DELAY			; FDC MAY TAKE UP TO 12us TO UPDATE MSR
	IN	A,(FDC_MSR)		; READ MAIN STATUS REGISTER
	AND	0C0H			; ISOLATE RQM/DIO
	CP	080H			; LOOKING FOR RQM=1, DIO=0 (FDC READY FOR A BYTE)
	JR	Z,FOP_CMD6		; GOOD, GO TO SEND BYTE
	CP	0C0H			; HMMMM... RQM=1 & DIO=1, FDC WANTS TO SEND US DATA, UNEXPECTED
	JP	Z,FOP_RES		; GO IMMEDIATELY TO RESULTS???
	DJNZ	FOP_CMD4		; LOOP TILL COUNTER EXHAUSTED
	JP	FOP_TOSNDCMD		; COUNTER EXHAUSTED, TIMEOUT / EXIT

FOP_CMD6:	; SEND NEXT BYTE
	LD	A,(HL)			; POINT TO NEXT BYTE TO SEND
	OUT	(FDC_DATA),A		; PUSH IT TO FDC
	INC	HL			; INCREMENT POINTER FOR NEXT TIME
	DEC	D			; DECREMENT NUM BYTES LEFT TO SEND
	JR	NZ,FOP_CMD2		; DO NEXT BYTE
;
; EXECUTION PHASE
;
FOP_X1:
	LD	A,(FCP_CMD)

	CP	CFD_READ
	JR	Z,FXR_READ
	CP	CFD_WRITE
	JR	Z,FXR_WRITE
	CP	CFD_READID
	JR	Z,FXR_NULL
	JP	FOP_RES
;;
;; EXECUTION ROUTINES
;;
;
; NULL EXECUTION, NO DATA TO READ/WRITE (USED BY SPECIFY, READID, ETC.)
;
; DO NOTHING, BUT WAIT FOR EXEC B IT TO CLEAR FDC READY.
; LOOP NEEDS TO ALLOW FOR 2 FULL ROTATIONS OF THE DISK
; WHICH IS 400ms AT 300RPM
;
FXR_NULL:
	LD	BC,$7000		; LOOP COUNTER, $7000 * 16us = ~485ms
FXR_NULL1:
	CALL	DELAY			; FDC MAY TAKE UP TO 12us TO UPDATE MSR
	IN	A,(FDC_MSR)		; GET MSR
	AND	0E0H			; ISOLATE RQM/DIO/NDM
	CP	0C0H			; WE WANT RQM=1,DIO=1,NDM=0 (READY TO READ A BYTE W/ EXEC INACTIVE)
	JP	Z,FOP_RES		; EXEC DONE, EXIT CLEAN W/O PULSING TC
	;JP	Z,FXR_NULL2		; *DEBUG*
	DEC	BC			; DECREMENT COUNTER (16 BIT)
	LD	A,B			; CHECK FOR ZERO
	OR	C			; "
	JR	NZ,FXR_NULL1		; NOT ZERO YET, KEEP CHECKING
	JP	FOP_TOEXEC		; TIMEOUT EXIT
;FXR_NULL2:	; *DEBUG*
;	CALL	PRTHEXBYTE
;	CALL	PRTHEXWORD
;	JP	FOP_RES
;
; READ DATA
;
FXR_READ:
	DI				; TIME CRITICAL , INTERRUPTS WILL CAUSE I/O ERRS
	LD	HL,(FD_DSKBUF)		; POINT TO SECTOR BUFFER START
	LD	DE,(FCD_SECSZ)
	; TIMEOUT COUNTER IS CPU MHZ / 4 (MAKING SURE IT IS AT LEAST 1)
;	LD	A,(CPUMHZ + 3) / 4
	LD	A,CPUMHZ		; GET CPU SPEED IN MHZ
	ADD	A,3			; ROUND UP
	SRL	A			; SHIFT RIGHT TWICE
	;SRL	A			; ... TO DIVIDE BY 4
	;INC	A			; MAKE SURE RESULT IS AT LEAST 1
	LD	(FCD_TO),A		; INIT TIMEOUT COUNTER
FXRR1:	LD	C,0			; OUTER LOOP TIMEOUT COUNTER
FXRR2:	LD	B,0			; SETUP FOR 256 ITERATIONS
FXRR3:	IN	A,(FDC_MSR)		; GET MSR
	CP	0F0H			; WE WANT RQM=1,DIO=1,NDM=1,BUSY=1 (READY TO RECEIVE A BYTE W/ EXEC ACTIVE)
	JR	Z,FXRR4			; GOT IT, DO BYTE READ
	DJNZ	FXRR3			; NOT READY, LOOP IF COUNTER NOT ZERO
	JR	FXRR5			; COUNTER ZERO, GO TO OUTER LOOP LOGIC

FXRR4:	IN	A,(FDC_DATA)		; GET PENDING BYTE
	LD	(HL),A			; STORE IT IN BUFFER
	INC	HL			; INCREMENT THE BUFFER POINTER
	DEC	DE			; DECREMENT BYTE COUNT
	LD	A,D
	OR	E
	JR	NZ,FXRR2		; IF NOT ZERO, REPEAT LOOP
	JR	FXR_END			; CLEAN EXIT

FXRR5:					; OUTER LOOP, REALLY ONLY HAPPENS WHEN WAITING FOR FIRST BYTE OR ABORTED
	AND	0E0H			; ISOLATE RQM/DIO/NDM
	CP	0C0H			; IF RQM=1, DIO=1, NDM=0 (EXECUTION ABORTED)
	JR	Z,FXR_ABORT		; BAIL OUT TO ERR ROUTINE, FIX: GO TO SPECIFIC ROUTINE FOR THIS???
	DEC	C
	JR	NZ,FXRR2		; IF NOT ZERO, LOOP SOME MORE
	LD	A,(FCD_TO)
	DEC	A
	LD	(FCD_TO),A
	JR	NZ,FXRR1
	JR	FXR_TO			; OTHERWISE, TIMEOUT ERROR
;
; WRITE DATA
;
FXR_WRITE:
	DI				; TIME CRITICAL , INTERRUPTS WILL CAUSE I/O ERRS
	LD	HL,(FD_DSKBUF)		; POINT TO SECTOR BUFFER START
	LD	DE,(FCD_SECSZ)
	; TIMEOUT COUNTER IS CPU MHZ / 4 (MAKING SURE IT IS AT LEAST 1)
;	LD	A,(CPUMHZ + 3) / 4
	LD	A,CPUMHZ		; GET CPU SPEED IN MHZ
	ADD	A,3			; ROUND UP
	SRL	A			; SHIFT RIGHT TWICE
	;SRL	A			; ... TO DIVIDE BY 4
	;INC	A			; MAKE SURE RESULT IS AT LEAST 1
	LD	(FCD_TO),A
FXRW1:	LD	C,0			; OUTER LOOP TIMEOUT COUNTER
FXRW2:	LD	B,0			; SETUP FOR 256 ITERATIONS
FXRW3:	IN	A,(FDC_MSR)		; GET MSR
	CP	0B0H			; WE WANT RQM=1,DIO=0,NDM=1,BUSY=1 (READY TO SEND A BYTE W/ EXEC ACTIVE)
	JR	Z,FXRW4			; GOT IT, DO BYTE WRITE
	DJNZ	FXRW3			; NOT READY, LOOP IF COUNTER NOT ZERO
	JR	FXRW5			; COUNTER ZERO, GO TO OUTER LOOP LOGIC
FXRW4:	LD	A,(HL)			; GET NEXT BYTE TO WRITE
	OUT	(FDC_DATA),A		; WRITE IT
	INC	HL			; INCREMENT THE BUFFER POINTER
	DEC	DE			; DECREMENT LOOP COUNTER
	LD	A,D
	OR	E
	JR	NZ,FXRW2		; IF NOT ZERO, REPEAT LOOP
	JR	FXR_END			; CLEAN EXIT
FXRW5:					; OUTER LOOP, REALLY ONLY HAPPENS WHEN WAITING FOR FIRST BYTE OR ABORTED
	AND	0E0H			; ISOLATE RQM/DIO/NDM
	CP	0C0H			; IF RQM=1, DIO=1, NDM=0 (EXECUTION ABORTED)
	JR	Z,FXR_ABORT		; BAIL OUT TO ERR ROUTINE
	DEC	C
	JR	NZ,FXRW2		; IF NOT ZERO, LOOP SOME MORE
	LD	A,(FCD_TO)
	DEC	A
	LD	(FCD_TO),A
	JR	NZ,FXRW1
	JR	FXR_TO			; OTHERWISE, TIMEOUT ERROR
;
; COMMON COMPLETION CODE FOR ALL EXECUTION ROUTINES
;
FXR_TO:		; TIMEOUT
	EI				; INTERRUPTS OK AGAIN
	JP	FOP_TOEXEC		; EXEC TIMEOUT
;
FXR_ABORT:	; EXECUTION ABORTED
	EI				; INTERRUPTS OK AGAIN
	JR	FOP_RES			; GET RSEULTS, NO NEED TO PULSE TC
;
FXR_END:	; EXECUTION COMPLETED NORMALLY
	CALL	FC_PULSETC		; PULSE TC TO END EXECUTION
	EI				; INTERRUPTS OK AGAIN
	JR	FOP_RES			; GET RSEULTS
;
; RESULTS PHASE
;
FOP_RES:
	LD	HL,FRB			; POINT TO RECEIVE BUFFER

FOP_RES0:
	LD	BC,$7000		; LOOP COUNTER, $7000 * 16us = ~458ms

FOP_RES1:
	CALL	DELAY			; FDC MAY TAKE UP TO 12us TO UPDATE MSR
	IN	A,(FDC_MSR)		; READ MAIN STATUS REGISTER
	AND	0F0H			; ISOLATE RQM/DIO/EXEC/BUSY
	CP	0D0H			; LOOKING FOR RQM/DIO/BUSY
	JR	Z,FOP_RES2		; GOOD, GO TO RECEIVE BYTE
	CP	080H			; CHECK FOR RQM=1, DIO=0 (NOTHING LEFT)
	JR	Z,FOP_EVAL		; IF NOTHING LEFT, ALL DONE, GO TO EOD/EXIT
	DEC	BC			; DECREMENT COUNTER (16 BIT)
	LD	A,B			; CHECK FOR ZERO
	OR	C			; ""
	JR	NZ,FOP_RES1		; LOOP TILL COUNTER EXHAUSTED
	;IN	A,(FDC_MSR)		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
	JR	FOP_TOGETRES		; OTHERWISE TIMEOUT ERROR

FOP_RES2:	; PROCESS NEXT PENDING BYTE
	LD	A,FRB_SIZ		; GET BUF SIZE
	CP	D			; REACHED MAX?
	JR	Z,FOP_BUFMAX		; HANDLE BUF MAX/EXIT
	IN	A,(FDC_DATA)		; GET THE BYTE
	LD	(HL),A			; SAVE VALUE
	INC	HL			; INCREMENT BUF POS
	INC	D			; INCREMENT BYTES RECEIVED
	PUSH	HL
	LD	HL,FRB_LEN		; POINT TO BUFFER LENGTH
	LD	(HL),D			; UPDATE NUMBER OF BYTES RECEIVED
	POP	HL
	JR	FOP_RES0		; CONTINUE READ LOOP
;
; EXIT POINTS
;
FOP_NOTIMPL:
	LD	A,FRC_NOTIMPL
	JR	FOP_ERR

FOP_CMDERR:
	LD	A,FRC_CMDERR
	JR	FOP_ERR

FOP_ERROR:
	LD	A,FRC_ERROR
	JR	FOP_ERR

FOP_ABORT:
	LD	A,FRC_ABORT
	JR	FOP_ERR

FOP_BUFMAX:
	LD	A,FRC_BUFMAX
	JR	FOP_ERR

FOP_TOFDCRDY:
	LD	A,FRC_TOFDCRDY
	JR	FOP_ERR

FOP_TOSNDCMD:
	LD	A,FRC_TOSNDCMD
	JR	FOP_ERR

FOP_TOGETRES:
	LD	A,FRC_TOGETRES
	JR	FOP_ERR

FOP_TOEXEC:
	LD	A,FRC_TOEXEC
	JR	FOP_ERR

FOP_ERR:
	LD	(FST_RC),A

FOP_EVAL:
	LD	A,(FCP_CMD)
	; DRVSTAT IS WEIRD, HAS ONLY ST3, NOTHING TO EVAL
	CP	CFD_DRVSTAT
	JR	Z,FOP_EXIT
	; DO WE HAVE ST0?
	LD	A,(FRB_LEN)
	CP	1
	JP	M,FOP_EXIT

FOP_EVALST0:
	LD	A,(FRB_ST0)
	AND	11000000B
	CP	01000000B		; ABTERM
	JR	Z,FOP_ABTERM
	CP	10000000B		; INVCMD
	JR	Z,FOP_INVCMD
	CP	11000000B		; DSKCHG
	JR	Z,FOP_DSKCHG
	JR	FOP_EXIT

FOP_ABTERM:
	; SENSEINT DOES NOT USE ST1
	LD	A,(FCP_CMD)
	CP	CFD_SENSEINT
	JR	Z,FOP_ABTERM1
	; DO WE HAVE ST1?
	LD	A,(FRB_LEN)
	CP	2
	JP	M,FOP_ABTERM1
	JR	FOP_EVALST1
FOP_ABTERM1:	; NO FURTHER DATA, SET FST TO ABTERM
	LD	C,FRC_ABTERM
	JR	FOP_SETFST

FOP_INVCMD:
	LD	C,FRC_INVCMD
	JR	FOP_SETFST

FOP_DSKCHG:
	LD	C,FRC_DSKCHG
	JR	FOP_SETFST

FOP_EVALST1:
	LD	A,(FRB_ST1)

	LD	C,FRC_ENDCYL
	BIT	7,A
	JR	NZ,FOP_SETFST

	LD	C,FRC_DATAERR
	BIT	5,A
	JR	NZ,FOP_SETFST

	LD	C,FRC_OVERRUN
	BIT	4,A
	JR	NZ,FOP_SETFST

	LD	C,FRC_NODATA
	BIT	2,A
	JR	NZ,FOP_SETFST

	LD	C,FRC_NOTWRIT
	BIT	1,A
	JR	NZ,FOP_SETFST

	LD	C,FRC_MISADR
	BIT	0,A
	JR	NZ,FOP_SETFST

	JR	FOP_EXIT

FOP_SETFST:
	LD	A,C
	LD	(FST_RC),A

FOP_EXIT:
	JP	FD_RETRC


	SECTION	DATA
;
;
;==================================================================================================
;   FLOPPY DISK DRIVER - DATA
;==================================================================================================
;
; FDC COMMAND PHASE
;
FCP_CMD:	DB	000H
FCP_LEN:	DB	00H
FCP_BUF:
FCP_CMDX:	DB	0
FCP_HDSDS:	DB	0
FCP_C:		DB	0
FCP_H:		DB	0
FCP_R:		DB	0
FCP_N:		DB	0
FCP_EOT:	DB	0
FCP_GPL:	DB	0
FCP_DTL:	DB	0
FCP_BUFSIZ:	EQU	$-FCP_BUF
;
; FDC STATUS
;
FST_RC:		DB	00H
FST_DOR:		DB	00H
FST_DCR:		DB	00H
;
; FDC RESULTS BUFFER
;
FRB_LEN:		DB	00H
FRB:
FRB_ST0:
FRB_ST3:		DB	0
FRB_ST1:
FRB_PCN:		DB	0
FRB_ST2:		DB	0
FRB_C:		DB	0
FRB_H:		DB	0
FRB_R:		DB	0
FRB_N:		DB	0
FRB_SIZ:		EQU	$-FRB
;
; FDC COMMAND DATA
;
FCD:		; FLOPPY CONFIGURATION DATA (PUBLIC) MANAGED AS A "BLOCK"
FCD_NUMCYL:	DB	000H		; NUMBER OF CYLINDERS
FCD_NUMHD:	DB	000H		; NUMBER OF HEADS
FCD_NUMSEC:	DB	000H		; NUMBER OF SECTORS
FCD_SOT:		DB	000H		; START OF TRACK (ID OF FIRST SECTOR, USUALLY 1)
FCD_EOT:					; END OF TRACK SECTOR (SAME AS SC SINCE SOT ALWAYS 1)
FCD_SC:		DB	000H		; SECTOR COUNT
FCD_SECSZ:	DW	000H		; SECTOR SIZE IN BYTES
FCD_GPL:		DB	000H		; GAP LENGTH (R/W)
FCD_GPLF:	DB	000H		; GAP LENGTH (FORMAT)
FCD_SRTHUT:	DB	000H		; STEP RATE, IBM PS/2 CALLS FOR 3ms, 0DH = 3ms SRT, HEAD UNLOAD TIME
FCD_HLTND:	DB	000H		; HEAD LOAD TIME, IBM PS/2 CALLS FOR 15ms 08H = 16ms HUT
FCD_DOR:		DB	000H		; DOR VALUE
FCD_DCR:		DB	000H		; DCR VALUE
FCD_LEN:		EQU	$ - FCD
		; DYNAMICALLY MANAGED (PUBLIC)
FCD_DS:		DB	001H		; DRIVE SELECT (UNIT NUMBER 0-3)
FCD_C:		DB	000H		; CYLINDER
FCD_H:		DB	000H		; HEAD
FCD_R:		DB	001H		; RECORD
FCD_D:		DB	0E5H		; DATA FILL BYTE
		; STATUS MANAGEMENT
FCD_DOP:		DB	0FFH		; CURRENT OPERATION (SEE DOP_...)
FCD_IDLECNT:	DW	0		; IDLE COUNT
FCD_TO:		DB	0		; TIMEOUT COUNTDOWN TIMER
FCD_FDCRDY:	DB	0		; FALSE MEANS FDC RESET NEEDED
;
; GENERAL WORKING STORAGE
;
FD_DSKBUF:	DW	0
FD_CURGEOM:	EQU	$		; TWO BYTES BELOW
FD_CURSPT:	DB	0		; CURRENT SECTORS PER TRACK
FD_CURHDS:	DB	0		; CURRENT HEADS


	SECTION	CODE

;==================================================================================================
; DISK READ HELPER
;==================================================================================================
;
; IMPLEMENTS MULTI SECTOR READS AND I/O TO/FROM
; BANKED RAM VIA BOUNCE BUFFER
;
; TOS=READ FN ADR
; HL=BUF ADR
; E=SEC COUNT
; D=BUF BANK ID
;
; TODO
HB_DSKREAD:
	DI
	HALT
	RET


;==================================================================================================
; DISK WRITE HELPER
;==================================================================================================
;
; IMPLEMENTS MULTI SECTOR WRITES AND I/O TO/FROM
; BANKED RAM VIA BOUNCE BUFFER
;
; TOS=WRITE FN ADR
; HL=BUF ADR
; E=SEC COUNT
; D=BUF BANK ID
;
; TODO
HB_DSKWRITE:
	DI
	HALT
	RET











;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GENERAL UTILS
;
; MULTIPLY 8-BIT VALUES
; IN:  MULTIPLY H BY E
; OUT: HL = RESULT, E = 0, B = 0
;
MULT8:
	LD D,0
	LD L,D
	LD B,8
MULT8_LOOP:
	ADD HL,HL
	JR NC,MULT8_NOADD
	ADD HL,DE
MULT8_NOADD:
	DJNZ MULT8_LOOP
	RET

JPHL:	JP	(HL)

;;
;; COMPUTE HL / DE
;; RESULT IN BC, REMAINDER IN HL, AND SET ZF DEPENDING ON REMAINDER
;; A, DE DESTROYED
;;
;DIV:
;	XOR	A
;	LD	BC,0
;DIV1:
;	SBC	HL,DE
;	JR	C,DIV2
;	INC	BC
;	JR	DIV1
;DIV2:
;	XOR	A
;	ADC	HL,DE		; USE ADC SO ZF IS SET
;	RET
;===============================================================
;
; COMPUTE HL / DE = BC W/ REMAINDER IN HL & ZF
;
DIV16:
	LD	A,H			; HL -> AC
	LD	C,L			; ...
	LD	HL,0			; INIT HL
	LD	B,16			; INIT LOOP COUNT
DIV16A:
	SCF
	RL	C
	RLA
	ADC	HL,HL
	SBC	HL,DE
	JR	NC,DIV16B
	ADD	HL,DE
	DEC	C
DIV16B:
	DJNZ	DIV16A			; LOOP AS NEEDED
	LD	B,A			; AC -> BC
	LD	A,H			; SET ZF
	OR	L			; ... BASED ON REMAINDER
	RET				; DONE
;
;
; SET HL TO IY+A, A IS TRASHED
;
LDHLIYA:
	PUSH	IY			; COPY INSTANCE DATA PTR
	POP	HL			; ... TO HL
	ADD	A,L			; ADD OFFSET TO LSB
	LD	L,A			; ... PUT BACK IN L
	RET	NC			; DONE IF CF NOT SET
	INC	H			; IF CF SET, BUMP MSB
	RET				; ... AND RETURN

ST32:
	; LD (BC),DE:HL
	PUSH	AF
	LD	A,L
	LD	(BC),A
	INC	BC
	LD	A,H
	LD	(BC),A
	INC	BC
	LD	A,E
	LD	(BC),A
	INC	BC
	LD	A,D
	LD	(BC),A
	POP	AF
	RET



	SECTION CODE


; DELAY 16US (CPU SPEED COMPENSATED) INCUDING CALL/RET INVOCATION
; REGISTER A AND FLAGS DESTROYED
; NO COMPENSATION FOR Z180 MEMORY WAIT STATES
; THERE IS AN OVERHEAD OF 3TS PER INVOCATION
;   IMPACT OF OVERHEAD DIMINISHES AS CPU SPEED INCREASES
;
; CPU SCALER (CPUSCL) = (CPUHMZ - 2) FOR 16US + 3TS DELAY
;   NOTE: CPUSCL MUST BE >= 1!
;
; EXAMPLE: 8MHZ CPU (DELAY GOAL IS 16US)
;   LOOP = ((6 * 16) - 5) = 91TS
;   TOTAL COST = (91 + 40) = 131TS
;   ACTUAL DELAY = (131 / 8) = 16.375US
;
	; --- TOTAL COST = (LOOP COST + 40) TS -----------------+
DELAY:				; 17TS (FROM INVOKING CALL)	|
	LD	A,CPUSCL	; 13TS				|
;								|
DELAY1:				;				|
	; --- LOOP = ((CPUSCL * 16) - 5) TS ------------+	|
	DEC	A		; 4TS			|	|
	JR	NZ,DELAY1	; 12TS (NZ) / 7TS (Z)	|	|
	; ----------------------------------------------+	|
;								|
	RET			; 10TS (RETURN)			|
	;-------------------------------------------------------+
;
; DELAY 16US * DE (CPU SPEED COMPENSATED)
; REGISTER DE, A, AND FLAGS DESTROYED
; NO COMPENSATION FOR Z180 MEMORY WAIT STATES
; THERE IS A 27TS OVERHEAD FOR CALL/RET PER INVOCATION
;   IMPACT OF OVERHEAD DIMINISHES AS DE AND/OR CPU SPEED INCREASES
;
; CPU SCALER (CPUSCL) = (CPUHMZ - 2) FOR 16US OUTER LOOP COST
;   NOTE: CPUSCL MUST BE > 0!
;
; EXAMPLE: 8MHZ CPU, DE=6250 (DELAY GOAL IS .1 SEC OR 100,000US)
;   INNER LOOP = ((16 * 6) - 5) = 91TS
;   OUTER LOOP = ((91 + 37) * 6250) = 800,000TS
;   ACTUAL DELAY = ((800,000 + 27) / 8) = 100,003US
;
	; --- TOTAL COST = (OUTER LOOP + 27) TS ------------------------+
VDELAY:				; 17TS (FROM INVOKING CALL)		|
;									|
	; --- OUTER LOOP = ((INNER LOOP + 37) * DE) TS ---------+	|
	LD	A,CPUSCL	; 13TS				|	|
;								|	|
VDELAY1:			;				|	|
	; --- INNER LOOP = ((CPUSCL * 16) - 5) TS ------+	|	|
	DEC	A		; 4TS			|	|	|
	JR	NZ,VDELAY1	; 12TS (NZ) / 7TS (Z)	|	|	|
	; ----------------------------------------------+	|	|
;								|	|
	DEC	DE		; 6TS				|	|
	LD	A,D		; 4TS				|	|
	OR	E		; 4TS				|	|
	JP	NZ,VDELAY	; 10TS				|	|
	;-------------------------------------------------------+	|
;									|
	RET			; 10TS (FINAL RETURN)			|
	;---------------------------------------------------------------+
;
; DELAY ABOUT 0.5 SECONDS
; 500000US / 16US = 31250
;
LDELAY:
	PUSH	AF
	PUSH	DE
	LD	DE,31250
	CALL	VDELAY
	POP	DE
	POP	AF
	RET



	SECTION IGNORE
