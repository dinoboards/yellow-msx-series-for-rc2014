SIO0BASE	EQU	$80		; SIO BASE PORT
SIO0A_DAT	EQU	SIO0BASE + 1	; DATA PORT
SIO0A_CMD	EQU	SIO0BASE + 0	; CONTROL/STATUS PORT

SIO0B_CMD	EQU	SIO0BASE + 2	; DATA PORT
SIO0B_DAT	EQU	SIO0BASE + 3    ; CONTROL/STATUS PORT

DAT_CH	EQU	SIO0B_DAT
CMD_CH	EQU	SIO0B_CMD


SIO_WR1VAL	EQU	$18		; WR1 VALUE FOR INT ON RECEIVED CHARS
SIO_RTSON	EQU	$EA
SIO_RTSOFF	EQU	$E8
SIO_BUFSZ	EQU	245
SIO_BUF_HI	EQU	132

SIO_INIT	MACRO	CMD, RTS
	; WR0: CHANNEL RESET CMD
	LD	A, 0
	OUT	(CMD), A
	LD	A, 018H
	OUT	(CMD), A

	; WR4: CLK BAUD PARITY STOP BIT
	LD	A, 4
	OUT	(CMD), A
	LD	A, 0C4H
	OUT	(CMD), A

	; WR1: INTERRUPT ON
	LD	A, 1
	OUT	(CMD), A
	LD	A, SIO_WR1VAL
	OUT	(CMD), A

	; WR2: IM2 VEC OFFSET
	LD	A, 2
	OUT	(CMD), A
	LD	A, 00H
	OUT	(CMD),A

	; WR3: 8 BIT RCV, CTS/DCD AUTO, RX ENABLE
	LD	A, 3
	OUT	(CMD), A
	LD	A, 0E1H
	OUT	(CMD), A

	; WR5: DTR, 8
	LD	A, 5
	OUT	(CMD), A
	LD	A, RTS
	OUT	(CMD), A
	ENDM


; SIO CHIP PROBE
; CHECK FOR PRESENCE OF SIO CHIPS AND POPULATE THE
; SIO_MAP BITMAP (ONE BIT PER CHIP).  THIS DETECTS
; CHIPS, NOT CHANNELS.  EACH CHIP HAS 2 CHANNELS.
; MAX OF TWO CHIPS CURRENTLY.  INT VEC VALUE IS TRASHED!
;
SIO_PROBE:
	; INIT THE INT VEC REGISTER OF ALL POSSIBLE CHIPS
	; TO ZERO.
	XOR	A
	LD	B, 2			; WR2 REGISTER (INT VEC)
	LD	C, SIO0B_CMD		; FIRST CHIP
	CALL	SIO_WR			; WRITE ZERO TO CHIP REG

	; FIRST POSSIBLE CHIP
	LD	C, SIO0B_CMD		; FIRST CHIP CMD/STAT PORT
	CALL	SIO_PROBECHIP		; PROBE IT
	RET
;
SIO_PROBECHIP:
	; READ WR2 TO ENSURE IT IS ZERO (AVOID PHANTOM PORTS)
	CALL	SIO_RD			; GET VALUE
	AND	$F0			; ONLY TOP NIBBLE
	RET	NZ			; ABORT IF NOT ZERO
	; WRITE INT VEC VALUE TO WR2
	LD	A,$FF			; TEST VALUE
	CALL	SIO_WR			; WRITE IT
	; READ WR2 TO CONFIRM VALUE WRITTEN
	CALL	SIO_RD			; REREAD VALUE
	AND	$F0			; ONLY TOP NIBBLE
	CP	$F0			; COMPARE
	RET

SIO_WR:
	OUT	(C),B			; SELECT CHIP REGISTER
	OUT	(C),A			; WRITE VALUE
	RET
;
SIO_RD:
	OUT	(C),B			; SELECT CHIP REGISTER
	IN	A,(C)			; GET VALUE
	RET

SIO_INIT_CHANNELS:
	DI
	SIO_INIT	SIO0A_CMD, SIO_RTSOFF
	SIO_INIT	SIO0B_CMD, SIO_RTSON
	EI
	RET

INSTALL_INTERRUPT_HANDLER:
	DI

	LD	DE, OLDINT		; GET ADDRESS OF OLD INT. HOOK SAVED AREA
	LD	HL, H_KEYI		; GET ADDRESS OF INTERRUPT ENTRY HOOK
	LD	BC, 5			; LENGHT OF HOOK IS 5 BYTES
	LDIR				; TRANSFER

	CALL	GETSL10

	LD	(H_KEYI+1), A		; SET SLOT ADDRESS
	LD	A, $F7			; 'RST 30H' INTER-SLOT CALL OPERATION CODE
	LD	(H_KEYI), A		; SET NEW HOOK OP-CODE
	LD	HL, SIO_INT		; GET OUR INTERRUPT ENTRY POINT
	LD	(H_KEYI+2), HL		; SET NEW INTERRUPT ENTRY POINT
	LD	A, $C9			; 'RET' OPERATION CODE
	LD	(H_KEYI+4), A		; SET OPERATION CODE OF 'RET'
	EI
	RET

REMOVE_INTERRUPT_HANDLER:
	LD	DE, H_KEYI
	LD	HL, OLDINT
	LD	BC, 5
	LDIR
	RET

SIO_INT:
	DI				; INTERRUPTS WILL BE RE-ENABLED BY MSX BIOS

	; CHECK TO SEE IF SOMETHING IS ACTUALLY THERE
	XOR	A			; READ REGISTER 0
	OUT	(CMD_CH), A
	IN	A, (CMD_CH)
	AND	$01			; ISOLATE RECEIVE READY BIT
	RET	Z			; NOTHING AVAILABLE ON CURRENT CHANNEL

	; RECEIVE CHARACTER INTO BUFFER
	IN	A, (DAT_CH)			; READ PORT

	; IGNORE FOR MOMENT

	RET
