SIO0BASE	EQU	$80		; SIO BASE PORT
SIO0A_DAT	EQU	SIO0BASE + 1	; DATA PORT
SIO0A_CMD	EQU	SIO0BASE + 0	; CONTROL/STATUS PORT

SIO0B_CMD	EQU	SIO0BASE + 2	; DATA PORT
SIO0B_DAT	EQU	SIO0BASE + 3    ; CONTROL/STATUS PORT

DAT_CH	EQU	SIO0B_DAT
CMD_CH	EQU	SIO0B_CMD


SIO_RTS:	DB	$FF		; 0 => RTS OFF, $FF => RTS ON
SIO_WR1VAL	EQU	$18		; WR1 VALUE FOR INT ON RECEIVED CHARS
SIO_RTSON	EQU	$EA
SIO_RTSOFF	EQU	$E8
; SIO_BUFSZ	EQU	245
; SIO_BUF_HI	EQU	132

SIO_INIT:	.macro	CMD, RTS
	; WR0: CHANNEL RESET CMD
	LD	A, 0
	OUT	(&CMD), A
	LD	A, 018H
	OUT	(&CMD), A

	; WR4: CLK BAUD PARITY STOP BIT
	LD	A, 4
	OUT	(&CMD), A
	LD	A, 0C4H
	OUT	(&CMD), A

	; WR1: INTERRUPT ON
	LD	A, 1
	OUT	(&CMD), A
	LD	A, SIO_WR1VAL
	OUT	(&CMD), A

	; WR2: IM2 VEC OFFSET
	LD	A, 2
	OUT	(&CMD), A
	LD	A, 00H
	OUT	(&CMD),A

	; WR3: 8 BIT RCV, CTS/DCD AUTO, RX ENABLE
	LD	A, 3
	OUT	(&CMD), A
	LD	A, 0E1H
	OUT	(&CMD), A

	; WR5: DTR, 8
	LD	A, 5
	OUT	(&CMD), A
	LD	A, &RTS
	OUT	(&CMD), A
	.ENDM

SIO_OUT_CHR:	.macro	chr
	LD 	A, &chr		; REQUEST NEXT PACKET
	OUT	(DAT_CH), A	; send to port
	.endm

SIO_OUT_A:	.macro
	OUT	(DAT_CH), A	; send to port
	.endm

; SIO CHIP PROBE
; CHECK FOR PRESENCE OF SIO CHIPS AND POPULATE THE
; SIO_MAP BITMAP (ONE BIT PER CHIP).  THIS DETECTS
; CHIPS, NOT CHANNELS.  EACH CHIP HAS 2 CHANNELS.
; MAX OF TWO CHIPS CURRENTLY.  INT VEC VALUE IS TRASHED!
;
SIO_PROBE:
	; INIT THE INT VEC REGISTER OF ALL POSSIBLE CHIPS
	; TO ZERO.
	XOR	A
	LD	B, 2			; WR2 REGISTER (INT VEC)
	LD	C, SIO0B_CMD		; FIRST CHIP
	CALL	SIO_WR			; WRITE ZERO TO CHIP REG

	; FIRST POSSIBLE CHIP
	LD	C, SIO0B_CMD		; FIRST CHIP CMD/STAT PORT
	CALL	SIO_PROBECHIP		; PROBE IT
	RET
;
SIO_PROBECHIP:
	; READ WR2 TO ENSURE IT IS ZERO (AVOID PHANTOM PORTS)
	CALL	SIO_RD			; GET VALUE
	AND	$F0			; ONLY TOP NIBBLE
	RET	NZ			; ABORT IF NOT ZERO
	; WRITE INT VEC VALUE TO WR2
	LD	A,$FF			; TEST VALUE
	CALL	SIO_WR			; WRITE IT
	; READ WR2 TO CONFIRM VALUE WRITTEN
	CALL	SIO_RD			; REREAD VALUE
	AND	$F0			; ONLY TOP NIBBLE
	CP	$F0			; COMPARE
	RET

SIO_WR:
	OUT	(C),B			; SELECT CHIP REGISTER
	OUT	(C),A			; WRITE VALUE
	RET
;
SIO_RD:
	OUT	(C),B			; SELECT CHIP REGISTER
	IN	A,(C)			; GET VALUE
	RET

SIO_INIT_CHANNELS:
	DI
	SIO_INIT	SIO0A_CMD, SIO_RTSOFF
	SIO_INIT	SIO0B_CMD, SIO_RTSON
	EI
	RET

SIO_INT:
	DI				; INTERRUPTS WILL BE RE-ENABLED BY MSX BIOS

	; CHECK TO SEE IF SOMETHING IS ACTUALLY THERE
	XOR	A			; READ REGISTER 0
	OUT	(CMD_CH), A
	IN	A, (CMD_CH)
	AND	$01			; ISOLATE RECEIVE READY BIT
	RET	Z			; NOTHING AVAILABLE ON CURRENT CHANNEL

	; RECEIVE CHARACTER INTO BUFFER
SIO_INTRCV1:
	IN	A, (DAT_CH)			; READ PORT

	LD      HL, FLAGS		; ENSURE RS232 IS MARKED AS CLOSED
	BIT     3, (HL)			; FLAG PORT OPEN?
	JR	NZ, SIO_INGEST_BYTE

	; PORT NOT OPENED, SO IGNORE BYTE, RESET RTS AND EXIT
	LD	A, 5			; SELECTED REGISTER WRITE 5
	OUT	(CMD_CH), A
	LD	A, SIO_RTSOFF
	OUT	(CMD_CH), A
	JR	SIO_INTRCV4

SIO_INGEST_BYTE
	LD	B, A			; SAVE BYTE READ

	LD	A, (RSIQLN)
	LD	C, A

	LD	HL, DATCNT
	LD	A, (HL)			; GET COUNT
	CP	C			; COMPARE TO BUFFER SIZE
	JR	Z, SIO_INTRCV4		; BAIL OUT IF BUFFER FULL, RCV BYTE DISCARDED

	INC	A			; INCREMENT THE COUNT
	LD	(HL), A			; AND SAVE IT

	LD	HL, (RSFCB)

	; CP	SIO_BUF_HI		; BUFFER GETTING FULL?
	; JR	NZ, SIO_INTRCV2		; IF NOT, BYPASS CLEARING RTS

	LD	A, 5			; SELECTED REGISTER WRITE 5
	OUT	(CMD_CH), A
	LD	A, SIO_RTSOFF
	OUT	(CMD_CH), A

	XOR	A
	LD	(SIO_RTS), A

	INC	C
	INC	C
	INC	C
	INC	C

SIO_INTRCV2:
	PUSH	HL			; SAVE ADR OF HEAD PTR
	LD	A, (HL)			; DEREFERENCE HL
	INC	HL
	LD	H, (HL)
	LD	L, A			; HL IS NOW ACTUAL HEAD PTR
	LD	(HL), B			; SAVE CHARACTER RECEIVED IN BUFFER AT HEAD

	INC	HL			; BUMP HEAD POINTER
	POP	DE			; RECOVER ADR OF HEAD PTR
	LD	A, L			; GET LOW BYTE OF HEAD PTR
	SUB	C			; SUBTRACT SIZE OF BUFFER AND POINTER
	CP	E			; IF EQUAL TO START, HEAD PTR IS PAST BUF END
	JR	NZ, SIO_INTRCV3		; IF NOT, BYPASS
	LD	H, D			; SET HL TO
	LD	L, E			; ... HEAD PTR ADR
	INC	HL			; BUMP PAST HEAD PTR
	INC	HL
	INC	HL
	INC	HL			; ... SO HL NOW HAS ADR OF ACTUAL BUFFER START

SIO_INTRCV3:
	EX	DE, HL			; DE := HEAD PTR VAL, HL := ADR OF HEAD PTR
	LD	(HL), E			; SAVE UPDATED HEAD PTR
	INC	HL
	LD	(HL), D
	; CHECK FOR MORE PENDING...

	XOR	A
	OUT	(CMD_CH), A		; READ REGISTER 0
	IN	A, (CMD_CH)		;
	RRA				; READY BIT TO CF
	JR	C, SIO_INTRCV1		; IF SET, DO SOME MORE

	LD	A, (SIO_RTS)
	OR	A
	JR	Z, SIO_INTRCV4		; ABORT NOW IF RTS IS OFF

	; TEST FOR NEW BYTES FOR A SHORT PERIOD OF TIME
	LD	B, 40
SIO_MORE:
	IN	A, (CMD_CH)		;
	RRA				; READY BIT TO CF
	JR	C, SIO_INTRCV1		; IF SET, DO SOME MORE
	DJNZ	SIO_MORE

SIO_INTRCV4:
	; RESET INTERRUPT STATE IN SIO (CHANNEL A CONTROLS CHANNEL B ALSO)
	LD	A, 0
	OUT	(SIO0A_CMD), A
	LD	A, $38
	OUT	(SIO0A_CMD), A
	RET







SIO_RCBBYT:
	LD	A, (RSIQLN)
	INC	A
	INC	A
	LD	B, A

	LD	HL, (RSFCB)
	DI				; AVOID COLLISION WITH INT HANDLER
	LD	A, (DATCNT)		; GET COUNT
	DEC	A			; DECREMENT COUNT
	LD	(DATCNT), A		; SAVE UPDATED COUNT
	CP	0			; BUFFER LOW THRESHOLD
	JR	NZ, SIO_IN1		; IF NOT, BYPASS SETTING RTS

	LD	A, 5			; RTS IS IN WR5
	OUT	(CMD_CH), A		; ADDRESS WR5
	LD	A, SIO_RTSON		; VALUE TO SET RTS
	OUT	(CMD_CH), A		; DO IT

	LD	A, 255
	LD	(SIO_RTS), A
SIO_IN1:
	INC	HL
	INC	HL			; HL NOW HAS ADR OF TAIL PTR
	PUSH	HL			; SAVE ADR OF TAIL PTR
	LD	A, (HL)			; DEREFERENCE HL
	INC	HL
	LD	H, (HL)
	LD	L, A			; HL IS NOW ACTUAL TAIL PTR
	LD	C, (HL)			; C := CHAR TO BE RETURNED
	INC	HL			; BUMP TAIL PTR
	POP	DE			; RECOVER ADR OF TAIL PTR
	LD	A, L			; GET LOW BYTE OF TAIL PTR
	SUB	B			; SUBTRACT SIZE OF BUFFER AND POINTER
	CP	E			; IF EQUAL TO START, TAIL PTR IS PAST BUF END
	JR	NZ, SIO_IN2		; IF NOT, BYPASS
	LD	H, D			; SET HL TO
	LD	L, E			; ... TAIL PTR ADR
	INC	HL			; BUMP PAST TAIL PTR
	INC	HL			; ... SO HL NOW HAS ADR OF ACTUAL BUFFER START
SIO_IN2:
	EX	DE, HL			; DE := TAIL PTR VAL, HL := ADR OF TAIL PTR
	LD	(HL), E			; SAVE UPDATED TAIL PTR
	INC	HL
	LD	(HL), D
	EI				; INTERRUPTS OK AGAIN
	LD	A, C			; MOVE CHAR TO RETURN TO A
	OR	A
	RET
